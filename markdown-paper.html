<!DOCTYPE html>
<html lang="en">

<head>
    <script id="mdContent" type="text/markdown" src="./documentation.mdd"></script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="https://fonts.cdnfonts.com/css/cmu-serif">
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/default.min.css">

    <script>
        MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked-highlight/lib/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>

    <style id="cssPageLayout">
        * {
            box-sizing: border-box;
        }

        :root {
            --paper-bg-color: #fff;
            --main-bg-color: #ccc;
            --paper-width: 210mm;
            --paper-height: 297mm;
            --font-annotation-size: 0.8rem;

            --border-hint: 1px solid #c2c2c2;
            --border-radius: 0.2rem;

            --paper-padding: 20mm;
            --cornell-space: 0mm;
            --column-count: 2;
            --font-family: 'CMU Serif', Georgia, serif;
            --font-size: 9pt;
            --text-align: justify;
            --hyphens: auto;
        }

        html,
        body {
            background: var(--main-bg-color);
            width: 100%;
            min-height: 100dvh;
            margin: 0;
            padding: 0;

            font-family: var(--font-family);
            font-size: var(--font-size);
        }

        #pages {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 2rem;
            margin: 2rem auto;
        }

        .page {
            flex: none;
            position: relative;
            display: flex;
            flex-direction: column;

            width: var(--paper-width);
            height: var(--paper-height);
            padding: 0 var(--paper-padding);

            background: var(--paper-bg-color);
            box-shadow: 0px 0px 32px -8px #0008;
            overflow: hidden;
        }

        .page-header,
        .page-footer {
            position: relative;
            flex: none;
            display: flex;
            justify-content: center;
            height: var(--paper-padding);
            font-size: var(--font-annotation-size);
            opacity: 66%;
        }

        .page-content {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            min-height: 0;
            height: 100%;
        }

        .page-no {
            position: absolute;
            right: 0rem;
        }

        .page-header .page-no {
            bottom: 0rem;
        }

        .page-footer .page-no {
            top: 0rem;
        }

        .page-columns {
            min-height: 0;
            height: 100%;
            column-count: var(--column-count);
            column-gap: 2rem;
            column-fill: auto;
            padding-right: var(--cornell-space);
        }

        .page-columns>* {
            break-inside: avoid;
            /* Allows for grouping elements */
        }

        .page-columns>*:first-child,
        .page-columns>*:first-child>*:first-child,
        .page-columns>*:first-child>*:first-child>*:first-child,
        .page-columns>*:first-child>*:first-child>*:first-child>*:first-child {
            margin-top: 0;
            /* Cant avoid margin collapse, so the first margin has to be removed too */
        }

        #page-template {
            display: none;
        }

        #file-picker {
            border: 5px dashed #1C6EA4;
            border-radius: 2rem;
            cursor: pointer;
        }

        .column-break {
            break-before: column;
            margin: 0;
        }


        @media print {

            html,
            body {
                background: var(--paper-bg-color);
            }

            #pages {
                display: block;
                margin: 0;
            }

            .page {
                box-shadow: none;
                break-inside: avoid;
            }
        }
    </style>

    <style id="cssMarkdownStandard">
        p {
            hyphens: var(--hyphens);
            text-align: var(--text-align);
        }

        blockquote p,
        code p,
        a,
        .ref-foot p,
        .ref-cap p,
        .ref-cit-list p {
            text-align: unset;
            hyphens: unset;
        }

        .ref-foot p,
        .ref-cit-content p {
            margin: 0;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            margin: 2rem 0 0 0;
            break-after: avoid;
        }

        h1 {
            text-align: center;
            font-size: 3.0rem;
        }

        h2 {
            font-size: 1.8rem;
        }

        h3 {
            font-size: 1.5rem;
        }

        h4 {
            font-size: 1.3rem;
        }

        h5 {
            font-size: 1.1rem;
        }

        h6 {
            font-size: 1.0rem;
        }

        a {
            hyphens: unset;
            font-style: italic;
            color: inherit;
            text-decoration: inherit;
        }

        ul,
        ol {
            padding-inline-start: 2rem;
        }

        img {
            object-fit: contain;
            margin: auto;
            width: 100%;
            max-width: 100%;
            border-radius: var(--border-radius);
        }

        table {
            margin: 0 auto;
            border: none;
            border-collapse: collapse;
        }

        td {
            padding: 0 0.6rem;
            border-left: 1px solid #000;
        }

        tr {
            border-bottom: var(--border-hint);
        }

        thead {
            border-bottom: 1px solid #000;
        }

        table td:first-child {
            border-left: none;
        }


        pre {
            font-size: var(--font-annotation-size);
            display: block;
        }

        code {
            display: inline;
            padding: 0 0.3rem;
            font-size: var(--font-annotation-size);
            border: var(--border-hint);
            border-radius: var(--border-radius);
        }

        pre code {
            padding: 1rem;
            width: 100%;
            display: inline-block;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        blockquote {
            font-style: italic;
            border-top: var(--border-hint);
            border-bottom: var(--border-hint);
        }
    </style>

    <style id="cssMarkdownExtensions">
        .ref-cit-link,
        .ref-cap-link,
        .ref-foot-link {
            font-style: unset;
            text-decoration: underline;
        }

        .ref-cap-wrapper {
            margin: 1rem 0;
            break-inside: avoid;
        }

        .ref-cap {
            opacity: 66%;
            display: flex;
            gap: 0.5rem;
            align-items: baseline;
        }

        .ref-cap-key {
            font-weight: bold;
            text-wrap: nowrap;
        }

        .ref-cap-content * {
            font-style: italic;
        }

        .ref-cit-list {
            break-inside: avoid;
        }

        .ref-cit-list table {
            border-collapse: separate;
            border-spacing: 0.5rem;
            font-size: var(--font-annotation-size);
        }

        .ref-cit-list td,
        .ref-cit-list tr {
            border: none;
            padding: 0;
            font-size: var(--font-annotation-size);
        }

        .ref-cit-key {
            vertical-align: text-top;
        }

        .ref-foot {
            opacity: 66%;
            font-size: var(--font-annotation-size);
            display: flex;
            gap: 0.5rem;
            padding: 0.25rem 0;
        }

        .ref-foot-link {
            font-size: 0.6rem;
        }

        .toc-list {
            padding-left: 1rem;
        }

        .toc-item {
            width: 100%;
            display: flex;
            gap: .5rem;
            align-items: baseline;
            padding: 0.125rem 0rem;
        }

        .toc-item-dots {
            flex: 1 1 auto;
            border-bottom: 1px dotted;
        }

        .mxgraph,
        .mxgraph svg {
            width: 100% !important;
            height: unset !important;
            min-width: unset !important;
            min-height: unset !important;
        }

        .mxgraph svg {
            background-size: contain;
        }

        .geAdaptiveAsset {
            display: none;
        }
    </style>

</head>

<body>

    <div id="pages">
        <!-- All pages are added here -->
    </div>

    <div id="file-picker" class="page">
        <!-- Selecting a markdown file -->
        <div id="file-picker-page" style="margin: auto; opacity: 66%; text-align: center;">
            <h2>Drag and drop your markdown</h2>
            <h2>Or click to pick</h2>
            <input id="file-picker-input" style="position:absolute; top:-2rem; display: none;" type="file"
                accept=".md,text/markdown,text/plain" />
        </div>
    </div>

    <div id="page-template" class="page">
        <!-- Defines the structure of a single page -->
        <div class="page-header">
            <p class="page-no"></p>
        </div>

        <div class="page-content">
            <div class="page-top"></div>
            <div class="page-columns"></div>
            <div class="page-bottom"></div>
        </div>

        <div class="page-footer">
            <p class="page-no"></p>
        </div>
    </div>

    <div id="toc-list-template" class="toc-list">
        <!-- Table of contents list -->
        <a class="toc-item">
            <span class="toc-item-heading"></span>
            <span class="toc-item-dots"></span>
            <span class="toc-item-page"></span>
        </a>
    </div>

    <div id="ref-cit-list-template" class="ref-cit-list">
        <!-- Reference list -->
        <table>
            <tr class="ref-cit">
                <td class="ref-cit-key"></td>
                <td class="ref-cit-content"></td>
            </tr>
        </table>
    </div>

    <div id="ref-cap-wrapper-template" class="ref-cap-wrapper">
        <!-- Captions for figures, tables, etc -->
        <div class="ref-cap">
            <div class="ref-cap-key"></div>
            <div class="ref-cap-content"></div>
        </div>
    </div>

    <div id="ref-foot-template" class="ref-foot">
        <!-- Footnote template -->
        <sup class="ref-foot-key"></sup>
        <div class="ref-foot-content"></div>
    </div>

    <div id="diagram-template" class="mxgraph" data-mxgraph='{"resize": true, "center": true, {{content}}}'>
        <!-- Wrapper for draw.io diagrams -->
    </div>


    <!-- Documentation link -->
    <div style="position: fixed; top: 1rem; left: 1rem; cursor: pointer; font-family: sans-serif;">
        <div
            style="background-color: #1c6ea469;  border-radius: 100%; width: 3rem; height: 3rem; display: flex; box-shadow: 0px 0px 32px -8px #0008;">
            <div style="margin: auto; font-size: 2rem; font-weight: bold; text-align: center; vertical-align: middle;">
                <a href="https://wasserwecken.github.io/markdownpaper/?content=doc/documentation.md"
                    style="font-style: normal;">🕮</a>
            </div>
        </div>
    </div>

    <!-- Github link -->
    <div style="position: fixed; top: 5rem; left: 1rem; cursor: pointer; font-family: sans-serif;">
        <div
            style="background-color: #1c6ea469;  border-radius: 100%; width: 3rem; height: 3rem; display: flex; box-shadow: 0px 0px 32px -8px #0008;">
            <div style="margin: auto; font-size: 2rem; font-weight: bold; text-align: center; vertical-align: middle;">
                <a href="https://github.com/Wasserwecken/markdownpaper" style="font-style: normal;">#</a>
            </div>
        </div>
    </div>


    <script>
        // https://github.com/markedjs/marked-highlight/issues/257
        const { Marked } = window.marked;
        const { markedHighlight } = window.markedHighlight;
        const marked = new Marked(
            markedHighlight({
                langPrefix: 'hljs language-',
                highlight(code, lang, info) {
                    const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                    return hljs.highlight(code, { language }).value;
                }
            })
        );


        /**
         *
         */
        function LoadTemplates() {
            const diagram = document.querySelector('#diagram-template');
            diagram.id = '';
            diagram.remove();

            const filePicker = document.querySelector('#file-picker');
            filePicker.remove();

            const page = document.querySelector('#page-template');
            page.id = '';
            page.remove();

            const tocList = document.querySelector('#toc-list-template');
            const tocListItem = tocList.querySelector('.toc-item');
            tocList.id = '';
            tocList.innerHTML = '';
            tocList.remove();

            const refCitList = document.querySelector('#ref-cit-list-template');
            const refCitItem = refCitList.querySelector('.ref-cit');
            refCitList.id = '';
            refCitList.innerHTML = '';
            refCitList.remove();

            const refCapWrap = document.querySelector('#ref-cap-wrapper-template');
            refCapWrap.id = '';
            refCapWrap.remove();

            const refFootItem = document.querySelector('#ref-foot-template');
            refFootItem.id = '';
            refFootItem.remove();

            const templates = {
                Diagram: diagram,
                FilePicker: filePicker,
                Page: page,
                TocList: tocList,
                TocListItem: tocListItem,
                RefCitList: refCitList,
                RefCitItem: refCitItem,
                RefCapWrap: refCapWrap,
                RefFootItem: refFootItem,
            }

            filePicker.addEventListener("dragover", e => e.preventDefault());
            filePicker.addEventListener("click", e => filePicker.querySelector('#file-picker-input').click());
            filePicker.querySelector('#file-picker-input').addEventListener('change', e => {
                handleFileUpload(templates, e.target.files[0])
            });
            filePicker.addEventListener("drop", e => {
                e.preventDefault();
                handleFileUpload(templates, e.dataTransfer.files[0]);
            });

            return templates
        }

        /**
         *
         */
        function ExtractConfig(templates, contentDiv) {
            for (const header of contentDiv.querySelectorAll('mdHeader')) {
                const headerContent = document.createElement('div');
                headerContent.innerHTML = marked.parse(header.innerHTML);
                templates.Page.querySelector('.page-header').appendChild(headerContent);
                header.remove();
            }

            for (const footer of contentDiv.querySelectorAll('mdFooter')) {
                const footerContent = document.createElement('div');
                footerContent.innerHTML = marked.parse(footer.innerHTML);
                templates.Page.querySelector('.page-footer').appendChild(footerContent);
                footer.remove();
            }

            const mainHeadline = contentDiv.querySelector('H1');
            if (mainHeadline) {
                document.title = mainHeadline.innerHTML;
            }

            let config = {
                Columns: 2,
                Padding: "20mm",
                Hyphen: true,
                FontSize: "9pt",
                CornellSize: "0",
                FontFamily: `'CMU Serif', Georgia, serif`,
                TextAlign: "justify",
            };
            const contentConfig = contentDiv.querySelector('mdConfig');
            if (contentConfig) {
                config.Columns = contentConfig.getAttribute('Columns') ?? config.Columns;
                config.Padding = contentConfig.getAttribute('Padding') ?? config.Padding;
                config.Hyphens = contentConfig.getAttribute('Hyphens') ?? config.Hyphens;
                config.CornellSpace = contentConfig.getAttribute('CornellSpace') ?? config.CornellSize;
                config.FontSize = contentConfig.getAttribute('FontSize') ?? config.FontSize;
                config.FontFamily = contentConfig.getAttribute('FontFamily') ?? config.FontFamily;
                config.TextAlign = contentConfig.getAttribute('TextAlign') ?? config.TextAlign;
                contentConfig.remove();
                AppendPageStyle(config);
            }

            return config;
        }

        /**
         *
         */
        function AppendPageStyle(config, pageId) {
            let pageStyle = document.head.querySelector('#pageStyle');
            if (!pageStyle) {
                pageStyle = document.createElement('style');
                pageStyle.id = 'pageStyle';
                document.head.appendChild(pageStyle);
            }

            pageId = pageId ? `#${pageId}` : ``;
            pageStyle.innerHTML += `\n${pageId}.page {
            --paper-padding: ${config.Padding};
            --cornell-space: ${config.CornellSpace};
            --column-count: ${config.Columns};
            --font-family: ${config.FontFamily};
            --font-size: ${config.FontSize};
            --text-align: ${config.TextAlign};
            --hyphens: ${config.Hyphen};\n}`;
        }


        /**
         *
         */
        function ProcessCitations(templates, contentDiv) {
            let citationEnum = 0;
            const citations = [];

            // iterate...
            for (const citation of contentDiv.querySelectorAll('mdCitation')) {
                const id = citation.getAttribute('id');
                let key = citation.getAttribute('key');

                // auto enumerate if there is no predefined key.
                if (!key) {
                    citationEnum++;
                    key = citationEnum.toString();
                }

                // manipulate and remember.
                citation.remove();
                citation.setAttribute('key', `[${key}]`);
                citations.push(citation);
            }

            // populate citation list.
            let citRefList = contentDiv.querySelector('mdCitations');
            if (citRefList) {
                templates.RefCitList.innerHTML = marked.parse(citRefList.innerHTML);
                citRefList.replaceWith(templates.RefCitList);
                citRefList = templates.RefCitList;

                const refTable = document.createElement('table');
                citRefList.appendChild(refTable);

                for (const citation of citations) {
                    const citListItem = templates.RefCitItem.cloneNode(true);
                    citListItem.id = citation.id;
                    citListItem.querySelector('.ref-cit-key').innerHTML = citation.getAttribute('key');
                    citListItem.querySelector('.ref-cit-content').innerHTML = marked.parse(citation.innerHTML);
                    refTable.appendChild(citListItem);
                }
            }

            return citations;
        }

        /**
         *
         */
        function ProcessCaptions(templates, contentDiv) {
            const captions = {};
            const captionEnums = {};

            // iterate...
            for (const caption of [...contentDiv.querySelectorAll('mdCaption')]) {
                const id = caption.getAttribute('id');
                const type = caption.getAttribute('type');
                let key = caption.getAttribute('key');

                // group captions by their type
                if (!(type in captions)) {
                    captions[type] = [];
                    captionEnums[type] = 0;
                }

                // auto enumerate if there is no predefined key.
                if (!key) {
                    captionEnums[type]++;
                    key = type.charAt(0).toUpperCase() + type.slice(1);
                    key += ' ' + captionEnums[type].toString();
                }

                // create wrapper for the caption and the target.
                const captionWrap = templates.RefCapWrap.cloneNode(true);
                captionWrap.id = caption.id;
                captionWrap.setAttribute('key', key);
                captionWrap.querySelector('.ref-cap-key').innerHTML = key;
                captionWrap.querySelector('.ref-cap-content').innerHTML = marked.parse(caption.innerHTML);
                captions[type].push(captionWrap);

                // bundle the previous element with the caption.
                let target = caption.previousElementSibling;

                // replace with wrapper.
                captionWrap.prepend(target);
                caption.replaceWith(captionWrap);
            }

            return captions;
        }

        /**
         *
         */
        function PrepareFootnotes(templates, contentDiv) {
            const footnotes = [];

            // iterate...
            for (const footnote of [...contentDiv.querySelectorAll('mdFootnote')]) {
                const footnoteItem = templates.RefFootItem.cloneNode(true);
                footnoteItem.id = footnote.id;
                footnoteItem.querySelector('.ref-foot-key').innerHTML = footnote.getAttribute('key');
                footnoteItem.querySelector('.ref-foot-content').innerHTML = marked.parse(footnote.innerHTML);
                footnotes.push(footnoteItem);
                footnote.remove();
            }

            return footnotes;
        }

        /**
         *
         */
        function ProcessReferencePointers(citations, captions, footnotes, contentDiv) {
            function replaceText(item, regex, replacement) {
                let template = document.createElement('div');
                template.innerHTML = replacement;
                regex = new RegExp(regex);

                [...item.childNodes]
                    .filter(e => e.nodeType === Node.TEXT_NODE)
                    .forEach(e => {
                        let match;
                        while ((match = regex.exec(e.textContent)) !== null) {
                            const before = e.splitText(match.index);
                            const after = before.splitText(match[0].length);

                            before.remove();
                            template.cloneNode(true).childNodes
                                .forEach(e => after.parentNode.insertBefore(e, after));

                            e = after;
                            regex.lastIndex = 0;
                        }
                    });
            }

            const excludes = ['code', 'svg', 'iframe', 'img', 'blockquote'].map(e => `${e}, ${e} *`).join(', ');
            const allExcept = `*:not(${excludes})`;
            for (const item of contentDiv.querySelectorAll(allExcept)) {

                // replace citation pointers
                for (const citation of citations) {
                    const key = citation.getAttribute('key');
                    const link = `<a class="ref-cit-link" href="#${citation.id}">${key}</a>`;
                    replaceText(item, `\\[${citation.id}\\]`, link);
                }

                // replace caption pointers
                for (const [type, list] of Object.entries(captions)) {
                    for (const caption of list) {
                        const key = caption.getAttribute('key');
                        const link = `<a class="ref-cit-link" href="#${caption.id}">${key}</a>`;
                        replaceText(item, `\\[${caption.id}\\]`, link);
                    }
                }

                // prepare footnote pointers.
                for (const footnote of footnotes) {
                    const key = footnote.getAttribute('key') ?? footnote.id;
                    const link = `<sup class="ref-foot-link" refId="${footnote.id}">${key}</sup>`;
                    replaceText(item, `\\[${footnote.id}\\]`, link);
                }
            }
        }

        /**
         *
         */
        function EnumerateHeadings(templates, contentDiv) {
            const headings = [...contentDiv.querySelectorAll('h2, h3, h4, h5, h6')];

            // enumerate...
            let headingLevels = [0, 0, 0, 0, 0, 0];
            for (const heading of headings) {

                // skip marked headings
                if (heading.innerHTML.startsWith('[!]')) {
                    heading.innerHTML = heading.innerHTML.replace('[!]', '');
                    heading.id = heading.innerHTML.replace(/\s/g, '');;
                    continue;
                }

                // count and label
                const level = parseInt(heading.tagName[1]) - 1;
                headingLevels[level - 1]++;
                for (let i = level; i < headingLevels.length; i++) {
                    headingLevels[i] = 0;
                }
                const prefix = headingLevels.map(e => Math.max(1, e)).slice(0, level).join(".");
                heading.id = `h${prefix.replaceAll('.', '-')}`;
                heading.innerHTML = `${prefix}. ${heading.innerHTML}`;

                // bundle heading with the next node to avoid page or column splits
                const wrapper = document.createElement('div');
                const nextNode = heading.nextElementSibling;
                heading.replaceWith(wrapper);
                wrapper.appendChild(heading);
                wrapper.appendChild(nextNode);
            }

            // build the table of contens.
            let tocDiv = contentDiv.querySelector('mdTableOfContents');
            if (tocDiv) {
                tocDiv.innerHTML = marked.parse(tocDiv.innerHTML);
                let previousLevel = 0;
                let levelList = tocDiv;
                const tocDepth = parseInt(tocDiv.getAttribute('depth')) || 6;

                for (const heading of headings) {
                    const level = parseInt(heading.tagName[1]) - 1;
                    if (level > tocDepth) {
                        continue;
                    }

                    // adjust list level
                    if (previousLevel < level) {
                        while (previousLevel != level && previousLevel < 6) {
                            levelList.appendChild(templates.TocList.cloneNode(false));
                            levelList = levelList.lastChild;
                            previousLevel += 1;
                        }
                    }
                    else if (previousLevel > level) {
                        levelList = levelList.parentNode;
                        while (previousLevel > level && previousLevel >= 0) {
                            levelList = levelList.parentNode;
                            previousLevel -= 1;
                        }
                        levelList.appendChild(templates.TocList.cloneNode(false));
                        levelList = levelList.lastChild;
                    }

                    // create entry
                    const tocItem = templates.TocListItem.cloneNode(true);
                    tocItem.href = `#${heading.id}`;
                    tocItem.querySelector('.toc-item-heading').innerHTML = heading.innerHTML;
                    levelList.appendChild(tocItem);
                }

                for (const item of [...tocDiv.childNodes]) {
                    tocDiv.parentNode.insertBefore(item, tocDiv);
                }
                tocDiv.remove();
            }

            return headings;
        }

        /**
         *
         */
        async function PreRenderAndWait(templates, contentDiv) {
            document.body.appendChild(contentDiv);

            // math rendering
            MathJax.typeset();

            // diagram rendering
            let diagrams = [];
            for (const graph of document.querySelectorAll('mdDiagram')) {
                const graphFrame = templates.Diagram.cloneNode(true);
                const srcPath = graph.getAttribute('src');
                let graphConfig = graphFrame.getAttribute('data-mxgraph');
                graphConfig = srcPath
                    ? graphConfig.replace("{{content}}", `"url": "${srcPath}"`)
                    : graphConfig.replace("{{content}}", `"xml": "${graph.innerHTML}"`);
                graphFrame.setAttribute('data-mxgraph', graphConfig);
                graph.replaceWith(graphFrame);
                diagrams.push(graphFrame)
            }

            // wait for diagrams to be processed
            GraphViewer.processElements();
            for (const diagram of diagrams) {
                while (diagram.children.length === 0) {
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }

            // wait for images to be loaded to know their size.
            for (let image of contentDiv.querySelectorAll('img')) {
                if (!image.complete) {
                    await new Promise(resolve => {
                        image.addEventListener('load', resolve, { once: true });
                        image.addEventListener('error', resolve, { once: true });
                    });
                }
            }

            contentDiv.remove();
        }

        /**
         *
         */
        function AddPage(templates, config, pageList) {
            // cleanup footnotes
            if (pageList.length > 0) {
                const usedLinks = pageList.at(-1).Columns.querySelectorAll('.ref-foot-link');
                const usedLinkIds = [...usedLinks].map(e => e.getAttribute('refId'));
                const pageNotes = pageList.at(-1).Footer.querySelectorAll('.ref-foot');

                pageNotes.forEach(e => {
                    if (!usedFootIds.includes(e.id)) {
                        e.remove();
                    }
                });
            }

            // build new page div
            const newPageDiv = templates.Page.cloneNode(true);
            const newPage = {
                Page: newPageDiv,
                Header: newPageDiv.querySelector('.page-header'),
                Footer: newPageDiv.querySelector('.page-footer'),
                Content: newPageDiv.querySelector('.page-content'),
                Top: newPageDiv.querySelector('.page-top'),
                Columns: newPageDiv.querySelector('.page-columns'),
                Bottom: newPageDiv.querySelector('.page-bottom'),
            }
            pageList.push(newPage);

            newPage.Page.id = `page-${pageList.length}`;
            newPage.Header.querySelector('.page-no').innerHTML = pageList.length;
            newPage.Footer.querySelector('.page-no').innerHTML = pageList.length;

            document.querySelector('#pages').appendChild(newPage.Page);
            AppendPageStyle(config, newPageDiv.id);

            return newPage;
        }

        /**
         *
         */
        function AppendPageElement(footnotes, page, target, contentItem) {
            page[target].appendChild(contentItem);

            const footLinks = contentItem.querySelectorAll('.ref-foot-link');
            for (const footLink of footLinks) {
                const refId = footLink.getAttribute('refId');
                let footItem = page.Bottom.querySelector(`#${refId}`);
                let footKey = footItem?.querySelector('.ref-foot-key');
                if (!footItem) {
                    footItem = footnotes.find(e => e.id == refId);
                    page.Bottom.appendChild(footItem);
                    footKey = footItem.querySelector('.ref-foot-key');
                    if (!footKey.innerHTML) {
                        footKey.innerHTML = page.Bottom.childNodes.length;
                    }
                }
                footLink.innerHTML = footKey.innerHTML;
            }
        }

        /**
         *
         */
        function BuildPages(templates, config, footnotes, contentDiv) {

            // remove empty paragraphs
            for (const empty of [...contentDiv.querySelectorAll('p')]) {
                if (!empty.innerHTML && !empty.hasAttributes()) {
                    empty.remove();
                }
            }

            // adds the first page
            const pageList = [];
            let topContent = [];
            let page = AddPage(templates, config, pageList);

            for (const contentItem of [...contentDiv.children]) {
                let content = [contentItem];

                // page break
                const pageBreak = contentItem.querySelector('mdPageBreak');
                if (pageBreak) {
                    config.Columns = pageBreak.getAttribute('Columns') ?? config.Columns;
                    config.Padding = pageBreak.getAttribute('Padding') ?? config.Padding;
                    config.Hyphens = pageBreak.getAttribute('Hyphens') ?? config.Hyphens;
                    config.CornellSize = pageBreak.getAttribute('CornellSize') ?? config.CornellSize;
                    config.FontSize = pageBreak.getAttribute('FontSize') ?? config.FontSize;
                    config.FontFamily = pageBreak.getAttribute('FontFamily') ?? config.FontFamily;
                    config.TextAlign = pageBreak.getAttribute('TextAlign') ?? config.TextAlign;

                    page = AddPage(templates, config, pageList);
                    continue;
                }
                // column break
                else if (contentItem.querySelector('mdColumnBreak')) {
                    contentItem.nextElementSibling?.classList.add('column-break');
                    continue;
                }
                // column span
                else if (contentItem.tagName == 'MDCOLUMNSPAN' || contentItem.querySelector('mdColumnSpan')) {
                    if (config.Columns > 1) {
                        topContent = topContent.concat(...contentItem.children);
                        continue;
                    }
                    else {
                        content = [...contentItem.children];
                    }
                }

                // iterate
                while (content.length > 0 || topContent.length > 0) {
                    let target;
                    let contentList;

                    if (topContent.length > 0 && page.Columns.children.length == 0) {
                        target = 'Top';
                        contentList = topContent;
                    } else {
                        target = 'Columns';
                        contentList = content;
                    }

                    const item = contentList.shift();
                    if (!item) {
                        break;
                    }
                    AppendPageElement(footnotes, page, target, item);

                    // check if the item is overflowing the page grid and move it to the next column.
                    gridRect = page.Content.getBoundingClientRect();
                    itemRect = item.getBoundingClientRect();
                    if (itemRect.bottom > gridRect.bottom || itemRect.right > gridRect.right) {
                        item.remove();
                        contentList.unshift(item);
                        page = AddPage(templates, config, pageList);
                    }
                }
            }

            return pageList;
        }

        async function EvaluatePageNo(pageList) {
            const pageDivList = pageList.map(e => e.Page)
            const tocItems = document.querySelectorAll('.toc-item');
            for (const item of tocItems) {
                const href = item.getAttribute("href")
                if (href.startsWith('#')) {
                    const target = document.querySelector(href);
                    let page = target.parentNode;
                    while (!page.classList.contains('page')) {
                        page = page.parentNode;
                    }
                    const pageNo = pageDivList.indexOf(page) + 1;
                    item.querySelector('.toc-item-page').innerHTML = pageNo;
                }
            }
        }

        /**
         *
         */
        async function LoadLocalMarkdown() {
            const markdownBlock = document.getElementById('mdContent');
            const urlParams = new URLSearchParams(document.location.search);
            const markdownSrc = urlParams.get('content') ?? markdownBlock.getAttribute('src');

            let markdownContent = markdownBlock.innerHTML;
            if (markdownSrc) {
                try {
                    const response = await fetch(markdownSrc);
                    markdownContent = response.status == 200
                        ? await response.text()
                        : undefined;
                } catch {
                    markdownContent = undefined;
                }
            }

            return markdownContent;
        }

        /**
         *
         */
        async function Render(templates, markdownContent) {
            const contentDiv = document.createElement('div');
            contentDiv.innerHTML = marked.parse(markdownContent);

            const config = ExtractConfig(templates, contentDiv);
            const citations = ProcessCitations(templates, contentDiv);
            const captions = ProcessCaptions(templates, contentDiv);
            const footnotes = PrepareFootnotes(templates, contentDiv);
            const headings = EnumerateHeadings(templates, contentDiv);

            ProcessReferencePointers(citations, captions, footnotes, contentDiv);
            await PreRenderAndWait(templates, contentDiv);

            const pageList = await BuildPages(templates, config, footnotes, contentDiv);
            await EvaluatePageNo(pageList);
        }

        /**
         *
         */
        function handleFileUpload(templates, file) {
            const reader = new FileReader();
            reader.onload = function (event) {
                templates.FilePicker.remove();
                Render(templates, event.target.result);
            };
            reader.readAsText(file);
        };

        /**
         *
         */
        window.onload = async () => {
            const templates = LoadTemplates();
            let markdownContent = await LoadLocalMarkdown();

            if (markdownContent) {
                await Render(templates, markdownContent);
            } else {
                document.querySelector('#pages').appendChild(templates.FilePicker);
            }
        };
    </script>
</body>

</html>